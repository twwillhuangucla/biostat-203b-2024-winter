---
title: "Biostat 203B Homework 2"
subtitle: Due Feb 9 @ 11:59PM
author: "Chun-Siang Huang, 205111921 "
format:
  html:
    theme: cosmo
    embed-resources: true
    number-sections: false
    toc: true
    toc-depth: 4
    toc-location: left
    code-fold: false
knitr:
  opts_chunk: 
    cache: false    
    echo: true
    fig.align: 'center'
    fig.width: 6
    fig.height: 4
    message: FALSE
execute:
  eval: true    
---

Display machine information for reproducibility:
```{r}
sessionInfo()
```

Load necessary libraries (you can add more as needed).
```{r setup}
library(arrow)
library(data.table)
library(memuse)
library(pryr)
library(R.utils)
library(tidyverse)
library(duckdb)
```

Display memory information of your computer
```{r}
memuse::Sys.meminfo()
```

In this exercise, we explore various tools for ingesting the [MIMIC-IV](https://mimic.mit.edu/docs/iv/) data introduced in [homework 1](https://ucla-biostat-203b.github.io/2024winter/hw/hw1/hw1.html).

Display the contents of MIMIC `hosp` and `icu` data folders:

```{bash}
ls -l ~/mimic/hosp/
```

```{bash}
ls -l ~/mimic/icu/
```

## Q1. `read.csv` (base R) vs `read_csv` (tidyverse) vs `fread` (data.table)

### Q1.1 Speed, memory, and data types

There are quite a few utilities in R for reading plain text data files. Let us test the speed of reading a moderate sized compressed csv file, `admissions.csv.gz`, by three functions: `read.csv` in base R, `read_csv` in tidyverse, and `fread` in the data.table package.

Which function is fastest? Is there difference in the (default) parsed data types? How much memory does each resultant dataframe or tibble use? (Hint: `system.time` measures run times; `pryr::object_size` measures memory usage.) 

```{r}
system.time(admissions_base <- read.csv("~/mimic/hosp/admissions.csv.gz"))
system.time(admissions_tidyverse <-
  read_csv("~/mimic/hosp/admissions.csv.gz", show_col_types = FALSE))
system.time(admissions_fread <- fread("~/mimic/hosp/admissions.csv.gz"))
head(admissions_base, width = Inf) %>% rmarkdown::paged_table()
head(admissions_tidyverse, width = Inf) %>% rmarkdown::paged_table()
head(admissions_fread, width = Inf) %>% rmarkdown::paged_table()
pryr::object_size(admissions_base)
pryr::object_size(admissions_tidyverse)
pryr::object_size(admissions_fread)
```
**Answer:** The `fread` function is the fastest, followed by `read_csv`, and then `read.csv`. The `fread` function also produces a data table that uses less memory, 50.13MB, compared to the tibble created by read_csv, 55.31MB, and the dataframe by the base read.csv, 158.71MB.  The default parsed data types are also different between the 3 functions. The 'read.csv' function parses the numerical columns as 'integer' and all other columns as 'character'. The 'read_csv' function parses the numerical columns as 'double', columns containing date and time as 'POSIXct' and all other columns as 'character'. The 'fread' function parses the numerical columns as 'integer', columns containing date and time also as 'POSIXct', and all other columns as 'character'.

### Q1.2 User-supplied data types

Re-ingest `admissions.csv.gz` by indicating appropriate column data types in `read_csv`. Does the run time change? How much memory does the result tibble use? (Hint: `col_types` argument in `read_csv`.)
```{r}
system.time(admissions_tidyverse <- read_csv("~/mimic/hosp/admissions.csv.gz", 
  col_types = cols(
    subject_id = col_integer(),
    hadm_id = col_integer(),
    admittime = col_datetime(),
    dischtime = col_datetime(),
    deathtime = col_datetime(),
    admission_type = col_factor(),
    admit_provider_id = col_character(),
    admission_location = col_factor(),
    discharge_location = col_factor(),
    insurance = col_factor(),
    language = col_factor(),
    marital_status = col_factor(),
    race = col_factor(),
    edregtime = col_datetime(),
    edouttime = col_datetime(),
    hospital_expire_flag = col_factor()
)))
head(admissions_tidyverse, width = Inf)
pryr::object_size(admissions_tidyverse)
```
**Answer:** The run time shortens from 1.847s to 1.591s and the memory usage of the tibble also decreases from 55.31MB to 38.06MB.

## Q2. Ingest big data files

Let us focus on a bigger file, `labevents.csv.gz`, which is about 125x bigger than `admissions.csv.gz`.
```{bash}
ls -l ~/mimic/hosp/labevents.csv.gz
```
Display the first 10 lines of this file.
```{bash}
zcat < ~/mimic/hosp/labevents.csv.gz | head -10
```

### Q2.1 Ingest `labevents.csv.gz` by `read_csv`

Try to ingest `labevents.csv.gz` using `read_csv`. What happens? If it takes more than 5 minutes on your computer, then abort the program and report your findings. 
```{r, eval = FALSE}
#eval set to FALSE to avoid long run time
labevents_tidyverse <- read_csv("~/mimic/hosp/labevents.csv.gz")
```
**Answer:** The `read_csv` function takes more than 5 minutes to ingest `labevents.csv.gz` and was aborted. This is because the file is too large and there is no enough memory on this device to ingest the file.

### Q2.2 Ingest selected columns of `labevents.csv.gz` by `read_csv`

Try to ingest only columns `subject_id`, `itemid`, `charttime`, and `valuenum` in `labevents.csv.gz` using `read_csv`.  Does this solve the ingestion issue? (Hint: `col_select` argument in `read_csv`.)
```{r, eval = FALSE}
#eval set to FALSE to avoid long run time
labevents_tidyverse <- 
  read_csv("~/mimic/hosp/labevents.csv.gz", 
    col_select = c(subject_id, itemid, charttime, valuenum)
  )
```
**Answer:** The `read_csv` function still takes more than 5 minutes to ingest `labevents.csv.gz` even when only the selected columns are ingested. This is because the file is still too large.

### Q2.3 Ingest subset of `labevents.csv.gz`

Our first strategy to handle this big data file is to make a subset of the `labevents` data.  Read the [MIMIC documentation](https://mimic.mit.edu/docs/iv/modules/hosp/labevents/) for the content in data file `labevents.csv`.

In later exercises, we will only be interested in the following lab items: creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), and glucose (50931) and the following columns: `subject_id`, `itemid`, `charttime`, `valuenum`. Write a Bash command to extract these columns and rows from `labevents.csv.gz` and save the result to a new file `labevents_filtered.csv.gz` in the current working directory. (Hint: use `zcat <` to pipe the output of `labevents.csv.gz` to `awk` and then to `gzip` to compress the output. To save render time, put `#| eval: false` at the beginning of this code chunk.)

```{bash, eval = FALSE}
#eval set to FALSE to avoid long run time, to reproduce in full, set eval = TRUE 
zcat < ~/mimic/hosp/labevents.csv.gz | \
awk -F, 'BEGIN {OFS=","} ; NR==1 {print $2,$5,$7,$10} ; \
NR>1 {if ($5 == 50912 || $5 == 50971 || $5 == 50983 || \
$5 == 50902 || $5 == 50882 || $5 == 51221 || $5 == 51301 || \
$5 == 50931) print $2,$5,$7,$10}' | gzip > labevents_filtered.csv.gz
```
Display the first 10 lines of the new file `labevents_filtered.csv.gz`. How many lines are in this new file? How long does it take `read_csv` to ingest `labevents_filtered.csv.gz`?
```{bash}
zcat < ./labevents_filtered.csv.gz |head -10
zcat < ./labevents_filtered.csv.gz | wc -l
```
```{r, message = F}
system.time(labevents_filtered <- read_csv("labevents_filtered.csv.gz"))
```
**Answer:** The first 10 lines of the new file `labevents_filtered.csv.gz (127MB)` are displayed. There are 24855910 lines in this new file. The `read_csv` function takes 16.046s to ingest `labevents_filtered.csv.gz`. 

### Q2.4 Ingest `labevents.csv` by Apache Arrow

Our second strategy is to use [Apache Arrow](https://arrow.apache.org/) for larger-than-memory data analytics. Unfortunately Arrow does not work with gz files directly. First decompress `labevents.csv.gz` to `labevents.csv` and put it in the current working directory. To save render time, put `#| eval: false` at the beginning of this code chunk.

```{bash, eval = FALSE}
#eval set to FALSE to avoid large file, to reproduce in full set eval = TRUE 
gzip -dk < ~/mimic/hosp/labevents.csv.gz > ./labevents.csv
```

Then use [`arrow::open_dataset`](https://arrow.apache.org/docs/r/reference/open_dataset.html) to ingest `labevents.csv`, select columns, and filter `itemid` as in Q2.3. How long does the ingest+select+filter process take? Display the number of rows and the first 10 rows of the result tibble, and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

```{r}
system.time(
  labevents_arrow <- arrow::open_dataset("labevents.csv", format = "csv") %>%
    select(subject_id, itemid, charttime, valuenum) %>%
    filter(itemid %in% 
      c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
    collect()
)

labevents_arrow$charttime <- 
  with_tz(labevents_arrow$charttime, tzone = "UTC") %>% 
  force_tz(tzone = "US/Eastern")
arrange(labevents_arrow, subject_id) %>% head(10)
nrow(labevents_arrow)
```
**Answer:** The ingest+select+filter process took 32.3s.  There are 24855909 rows in the resulting tibble which is the same as labevents_filtered.csv.gz because in labevents_filtered.csv.gz the first row is the headings row. The first 10 rows of the result tibble match those in Q2.3 \

Write a few sentences to explain what is Apache Arrow. Imagine you want to explain it to a layman in an elevator. \

**Answer:** Apache Arrow is a software development platform that is designed to process and transport large datasets and work across different programming languages. It does this by representing data in a columnar format, where each column is stored separately, to allow for more efficient in-memory processing. 

### Q2.5 Compress `labevents.csv` to Parquet format and ingest/select/filter

Re-write the csv file `labevents.csv` in the binary Parquet format (Hint: [`arrow::write_dataset`](https://arrow.apache.org/docs/r/reference/write_dataset.html).) How large is the Parquet file(s)? How long does the ingest+select+filter process of the Parquet file(s) take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

```{r, eval = FALSE}
#eval set to FALSE to avoid large file, to reproduce in full set eval = TRUE
arrow::write_dataset(
  arrow::open_dataset("labevents.csv", format = "csv"), 
  "./labevents.parquet", format = "parquet")
```
```{r}
system.time(
  labevents_parquet <- 
    arrow::open_dataset("./labevents.parquet/part-0.parquet", 
      format = "parquet") %>%
    select(subject_id, itemid, charttime, valuenum) %>%
    filter(itemid %in% 
      c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
    collect()
)
labevents_parquet$charttime <- 
  with_tz(labevents_parquet$charttime, tzone = "UTC") %>% 
  force_tz(tzone = "US/Eastern")
arrange(labevents_parquet, subject_id) %>% head(10)
nrow(labevents_parquet)
```
**Answer:** The Parquet file is 1.9GB which is significantly smaller than the original labevents.csv file. The ingest+select+filter process of the Parquet file took 7.3s which is also a lot faster than just ingesting by Apache Arrow. The number of rows and first 10 rows of the result tibble match those in Q2.3. \

Write a few sentences to explain what is the Parquet format. Imagine you want to explain it to a layman in an elevator. \

**Answer:** The Parquet format is a file storing format that is designed to be efficient for reading and writing large datasets by storing data in a columnar format. It is open standard and is part of the Apache Arrow project.

### Q2.6 DuckDB

Ingest the Parquet file, convert it to a DuckDB table by [`arrow::to_duckdb`](https://arrow.apache.org/docs/r/reference/to_duckdb.html), select columns, and filter rows as in Q2.5. How long does the ingest+convert+select+filter process take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

```{r}
system.time(
  labevents_duckdb <- 
    arrow::open_dataset("./labevents.parquet/part-0.parquet", 
      format = "parquet") %>%
    arrow::to_duckdb() %>%
    select(subject_id, itemid, charttime, valuenum) %>%
    filter(itemid %in% 
      c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
    collect()
)

labevents_duckdb$charttime <- 
  force_tz(labevents_duckdb$charttime, tzone = "US/Eastern")
arrange(labevents_duckdb, subject_id) %>% head(10)
nrow(labevents_duckdb)
```
**Answer:** The ingest+convert+select+filter process took 7.7s. The number of rows and first 10 rows of the result tibble match those in Q2.3. \

Write a few sentences to explain what is DuckDB. Imagine you want to explain it to a layman in an elevator. \

**Answer:** DuckDB is a database management system that is designed for efficient querying and analysis of large datasets. It has features such as using columnar storage and vectorized execution, where query operations are performed on entire columns at once, to allow for fast processing of data.

## Q3. Ingest and filter `chartevents.csv.gz`

[`chartevents.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/chartevents/) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patient’s information is their electronic chart. The `itemid` variable indicates a single measurement type in the database. The `value` variable is the value measured for `itemid`. The first 10 lines of `chartevents.csv.gz` are
```{bash}
zcat < ~/mimic/icu/chartevents.csv.gz | head -10
```
[`d_items.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/d_items/) is the dictionary for the `itemid` in `chartevents.csv.gz`.
```{bash}
zcat < ~/mimic/icu/d_items.csv.gz | head -10
```
In later exercises, we are interested in the vitals for ICU patients: heart rate (220045), mean non-invasive blood pressure (220181), systolic non-invasive blood pressure (220179), body temperature in Fahrenheit (223761), and respiratory rate (220210). Retrieve a subset of `chartevents.csv.gz` only containing these items, using the favorite method you learnt in Q2. 

Document the steps and show code. Display the number of rows and the first 10 rows of the result tibble.

```{bash, eval = FALSE}
#eval set to FALSE to avoid large file to reproduce in full set eval = TRUE
gzip -dk < ~/mimic/icu/chartevents.csv.gz > ./chartevents.csv
```
```{r, eval = FALSE}
#eval set to FALSE to avoid large file to reproduce in full set eval = TRUE
arrow::write_dataset(
  arrow::open_dataset("chartevents.csv", format = "csv"), 
  "./chartevents.parquet", format = "parquet")
```
```{r}
chartevents_parquet <- 
  arrow::open_dataset("./chartevents.parquet/part-0.parquet", 
    format = "parquet") %>%
  filter(itemid %in% c(220045, 220181, 220179, 223761, 220210)) %>%
  collect()

chartevents_parquet$charttime <- 
  with_tz(chartevents_parquet$charttime, tzone = "UTC") %>%
  force_tz(tzone = "US/Eastern")
chartevents_parquet$storetime <- 
  with_tz(chartevents_parquet$storetime, tzone = "UTC") %>%
  force_tz(tzone = "US/Eastern")
nrow(chartevents_parquet)
arrange(chartevents_parquet, subject_id) %>% head(10) %>% 
rmarkdown::paged_table()
```
